webrpc = v2             # version of webrpc schema format (ridl or json)

name = example          # name of your backend app
version = v0.0.1        # version of your schema
              

enum Kind: uint32
  - USER
  - ADMIN


struct Empty


struct User
  - id: uint64
    + json = id
    + go.field.name = ID
    + go.tag.db = id

  - username: string
    + json = USERNAME
    + go.tag.db = username

  - role: string
    + go.tag.db = -

  - kind: Kind # TODO: fix this.. should not be *Kind

struct SearchFilter
  - q: string

struct Version
  - webrpcVersion: string
  - schemaVersion: string
  - schemaHash: string

struct ComplexType
  - meta: map<string,any>
  - metaNestedExample: map<string,map<string,uint32>>
  - namesList: []string
  - numsList: []int64
  - doubleArray: [][]string
  - listOfMaps: []map<string,uint32>
  - listOfUsers: []User
  - mapOfUsers: map<string,User>
  - user: User


# syntax is: error <code> <name> <message> [-- <http status code>]
error 500100 InvalidUsername  "invalid username" -- 403 # sets 403 http status code
error 400100 MemoryFull       "system memory is full"


# TODO: we'll do this in the future..
# we can just define some json here, it will work :D cuz, why not..
#value NetworkNames: map<string,Chain> = '''{
#  "blah": { etc }
#}'''

#value AuthorName: string = "Peter"


# so this works like a type of field .. 
alias BigInt: string
  + go.field.type = prototyp.BigInt


service Example
  - Ping()
  - Status() => (status: bool)
  - Version() => (version: Version)
  - GetUser(header: map<string,string>, userID: uint64) => (code: uint32, user: User)
  - FindUser(s: SearchFilter) => (name: string, user: User)
  #- SomeMethod(SomeMethodRequest) => (SomeMethodResponse) # alternative form, which will use struct types, and flatten them

service ExampleAdmin
  - AdminAddUser(username: string) => (id: uint64)
