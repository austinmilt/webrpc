/* tslint:disable */
// hello-webrpc v1.0.0 87ce8159bce3ad056518dfb1f1877b1a1012b34d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "87ce8159bce3ad056518dfb1f1877b1a1012b34d"


const xhr = XMLHttpRequest

//
// Types
//
export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: {[key: string]: any}
  created_at?: string
}

export interface Page {
  num: number
}

export interface ExampleService {
  ping(headers?: object): Promise<PingReturn>
  getUser(args: GetUserArgs, headers?: object): Promise<GetUserReturn>
  // download(args: DownloadArgs, headers?: object): Promise<DownloadStream>
}

export interface PingArgs {
}

export interface PingReturn {
}

export interface GetUserArgs {
  id: number
}

export interface GetUserReturn {
  user: User  
}

export interface DownloadArgs {
  file: string
}

export interface DownloadReturn {
  base64: string  
}

export interface DownloadStream {
  open(args?: DownloadArgs, headers?: object): Promise<boolean|WebRPCError> // hmmpf..
  close(): void
  // onopen(handler: () => void): void
  onclose(handler: (err?: WebRPCError) => void): void
  ondata(handler: (data: DownloadReturn) => void): void
}


//
// Client
//
export class ExampleService implements ExampleService {
  private hostname: string
  // private fetch: Fetch
  private path = '/rpc/ExampleService/'

  constructor(hostname: string) { //, fetch: Fetch) {
    this.hostname = hostname
    // this.fetch = fetch
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }

  // TODO: idea for returning error as value... maybe, maybe not?
  // blah = (headers?: object): Promise<PingReturn|WebRPCError> => {
  //   return new Promise<PingReturn>((resolve, reject) => {
  //     resolve({})
  //   })
  // }

  ping = async (headers?: object): Promise<PingReturn> => {
    return new Promise<PingReturn>((resolve, reject) => {
      const req = new xhr()
      req.open('POST', this.url('Ping'))
      req.setRequestHeader('Content-Type', 'application/json')
  
      req.onload = (e) => {
        console.log(req.status)
        resolve({} as PingReturn)
      }
  
      req.send('{}')
    })

    // TODO: xhr has sync and async api? is there a diff? check node-xmlhttprequest in case..
    // and check eventsource-polyfill..

    // xhr
    // return {} as PingReturn

    // return this.fetch(
    //   this.url('Ping'),
    //   createHTTPRequest({}, headers)
    //   ).then((res) => {
    //   return buildResponse(res).then(_data => {
    //     return {
    //       // status: <boolean>(_data.status)
    //     }
    //   })
    // })
  }
  
  getUser = async (args: GetUserArgs, headers?: object): Promise<GetUserReturn> => {
    return new Promise<GetUserReturn>((resolve, reject) => {
      const req = new xhr()
      req.open('POST', this.url('GetUser'))
      req.setRequestHeader('Content-Type', 'application/json')

      req.onload = (e) => {
        console.log(req.status)
        const _data = JSON.parse(req.responseText)
        resolve({
          user: <User>(_data.user)
        })
      }

      // TODO: .onerror() .......

      req.send(JSON.stringify(args))
    })

    // return {} as GetUserReturn

    // return this.fetch(
    //   this.url('GetUser'),
    //   createHTTPRequest(args, headers)).then((resp) => {
    //   return buildResponse(resp).then(_data => {
    //     return {
    //       user: <User>(_data.user)
    //     }
    //   })
    // })
  }
  
  download = async (args: DownloadArgs, headers?: object): Promise<DownloadStream> => {
    const stream = new StreamClient<DownloadArgs, DownloadReturn>(this.url('Download'), args, headers)
    // const stream = new StreamReader(this.fetch, this.url('Download'), args, headers)
    await stream.open() // to be or not to be....?
    return stream
  }
  
}

class StreamClient<TArgs,TReturn> {
  private handlers: string
  private ondataListeners: Array<(data: TReturn) => void>
  private oncloseListeners: Array<(err?: WebRPCError) => void>
  // private signalController: AbortController

  // readyState ? opened, closed, closed-lost

  constructor(
    // private fetch: Fetch,
    private url: string,
    private args: TArgs | object,
    private headers?: object
  ) {
    this.oncloseListeners = []
    this.ondataListeners = []
    // this.signalController = new AbortController()
  }

  open = (args?: TArgs | object, headers?: object): Promise<boolean|WebRPCError> => {
    console.log('open() top')

    // Check if browser supports ReadableStream api. A polyfill like web-streams-polyfill
    // may be required for older browsers.
    // @ts-ignore
    // if (typeof ReadableStream == 'undefined') {
    //   throw new Error(`browser does not support ReadableStreams`)
    // }

    // Check if this.fetch supports streaming response bodies. A polyfill like whatwg-fetch
    // combined with web-streams-polyfill may be required for older browsers.
    // if (this.fetch.polyfill)
    // TODO ...
    // ..

    return new Promise<boolean>((resolve) => {
      // TODO: review this call, either something or nothing..

      const req = new xhr()
      req.open('POST', this.url)
      req.setRequestHeader('Content-Type', 'application/json')

      req.onload = (ev) => {
        // console.log(req.status)
        // const _data = JSON.parse(req.responseText)
        // resolve({
        //   user: <User>(_data.user)
        // })
        // console.log('download.onload =>', req.responseText)
      }

      req.onprogress = (ev) => {
        console.log('=> download.progress', req.responseText)
      }

      req.send(JSON.stringify(this.args))




      // this.fetch(
      //   this.url, 
      //   {
      //     ...createHTTPRequest((args || this.args) as object, headers || this.headers)//,
      //     // signal: this.signalController.signal
      //   }
      // ).then(resp => {

      //   // hmm, perhaps setup reader on "this".. we could..
      //   // then we'd have .read(), or make it private...

      //   this.read(resp)
      //   resolve(true) // TODO ..
      // }).catch(err => {
      //   console.log(err)
      // })
    })
  }

  // read = async (resp: Response) => {
  //   console.log('read me..')

  //   // const source = new ReadableStream(resp.body as any)
  //   const source = resp.body!

  //   console.log('wtfffffffffffffffff...?', source)

  //   const reader = source.getReader()

  //   var count = 0

  //   const stream = () => {
  //     return reader.read().then(result => {
  //       console.log('payload:', result)
  //       // const payload = decoder.decode(result.value || new Uint8Array, { stream: !result.done })
  //       // console.log('got:', payload)

  //       // @ts-ignore
  //       this.emitData({ data: { base64: JSON.stringify(result) } })

  //       count++

  //       if (count == 3) {
  //         reader.cancel()
  //         return
  //       }

  //       if (result.done) {
  //         // resolve(true)
  //         // return true
  //         return
  //       }
  //       stream()
  //     })
  //   }
  //   stream()
  // }

  close = () => {
    // instead, this.reader.cancel() // .. thank goodness..
    // this.signalController.abort()
  }

  // TODO, onopen ?

  ondata = (handler: (data: TReturn) => void) => {
    this.ondataListeners.push(handler)
  }

  onclose = (handler: (err?: WebRPCError) => void) => {
    this.oncloseListeners.push(handler)
  }

  private emitData = (data: TReturn) => {
    for (var i = 0; i < this.oncloseListeners.length; i++) {
      this.ondataListeners[i](data)
    }
  }

  private emitClose = async () => {

  }
}

export interface WebRPCError extends Error {
  code: string
  message: string
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json', 'Accept': '*/*' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', message: `client error, expecting JSON object but got: '${text}'` } as WebRPCError
    }
    if (!res.ok) {
      throw data as WebRPCError // webrpc error response
    }
    return data
  })
}

// export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
