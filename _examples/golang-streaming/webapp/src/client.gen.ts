/* tslint:disable */
// hello-webrpc v1.0.0 87ce8159bce3ad056518dfb1f1877b1a1012b34d
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/typescript
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "87ce8159bce3ad056518dfb1f1877b1a1012b34d"



//
// Types
//
export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  username: string
  role: Kind
  meta: {[key: string]: any}
  created_at?: string
}

export interface Page {
  num: number
}

export interface ExampleService {
  ping(headers?: object): Promise<PingReturn>
  getUser(args: GetUserArgs, headers?: object): Promise<GetUserReturn>
  download(args: DownloadArgs, headers?: object): Promise<DownloadStream>
}

export interface PingArgs {
}

export interface PingReturn {
}

export interface GetUserArgs {
  id: number
}

export interface GetUserReturn {
  user: User  
}

export interface DownloadArgs {
  file: string
}

export interface DownloadReturn {
  base64: string  
}

export interface DownloadStream {
  open(args?: DownloadArgs, headers?: object): Promise<Response>
  close(): void
  // onopen(handler: () => void): void
  onclose(handler: (err?: WebRPCError) => void): void
  ondata(handler: (data: DownloadReturn) => void): void
}


class StreamClient<TArgs,TData> {
  // private handlers: string
  private _fetch: Fetch
  private _reader: ReadableStreamDefaultReader<Uint8Array> | null
  private _ondataListeners: Array<(data: TData) => void>
  private _oncloseListeners: Array<(err?: WebRPCError) => void>

  // readyState ? opened, closed, closed-lost

  constructor(
    fetch: Fetch,
    private url: string,
    // private args: TArgs,
    // private headers?: object
  ) {
    this._fetch = (input, init) => fetch(input, init)
    this._oncloseListeners = []
    this._ondataListeners = []
  }

  open = async (args?: TArgs, headers?: object) => {
    console.log('open() top', args)

    this._reader = null

    const resp = await this._fetch(this.url, { ...createHTTPRequest(args, headers) })
    if (resp.body) {
      this._reader = resp.body.getReader()
    }

    // ...?
    await this.read()

    // we done...? ...
    this._reader = null

    return resp
  }

  read = async () => {
    console.log('read()')

    if (!this._reader) {
      // throw new Error('response body readable stream is unavailable')
      return
    }

    const reader = this._reader
    const decoder = new ChunkDecoder()

    var count = 0 // here for debug reasons..

    const stream = () => reader.read().then(result => {
      if (result.done) {
        // do we get final value or done first..? I think .done ..
        return
      }

      decoder.push(result.value).then(chunks => {
        for (let i=0; i < chunks.length; i++) {
          const payload = JSON.parse(chunks[i])
          if (payload.data) {
            this.emitData(payload.data)
          }
          // TODO: payload.error ...?
        }
      })

      // debug code--
      // count++
      // if (count == 3) {
      //   console.log('cancelling stream..')
      //   this.close()
      //   // reader.cancel()
      //   return
      // }
      // --debug code

      if (result.done) {
        // resolve(true)
        // return true
        return
      }
      stream()
    })
    stream()
  }

  close = () => {
    this._reader?.cancel('cancelled by client')
    this._reader = null
  }

  ondata = (handler: (data: TData) => void) => {
    this._ondataListeners.push(handler)
  }

  onclose = (handler: (err?: WebRPCError) => void) => {
    this._oncloseListeners.push(handler)
  }

  private emitData = (data: TData) => {
    // console.log('data:', data)
    for (let i=0; i < this._oncloseListeners.length; i++) {
      this._ondataListeners[i](data)
    }
  }

  private emitClose = async () => {

  }
}

class ChunkDecoder {
  private decoded: string[] = []
  private size: number = -1
  private value: number[] = []
  private state: number = 0 // 0=size, 1=reading data, 2=term

  push(bytes: Uint8Array): Promise<string[]> {

    this.decoded.length = 0

    return new Promise<string[]>((resolve, reject) => {
      if (this.state == 3) {
        resolve([])
        return
      }

      let i = 0, c = -1, l = -1
      const v = this.value

      while (i < bytes.length) {
        c = bytes[i]
        if (v.length > 0) {
          l = v[v.length-1]
        }

        switch (this.state) {
          case 0: // new chunk
            if (l == 13 && c == 10) {
              this.size = parseInt("0x"+this.utf8ArrayToStr(v.slice(0,v.length-1)))
              if (this.size == 0) {
                this.state = 3
              } else {
                this.state = 1
              }
              v.length = 0
            } else {
              v.push(c)
            }
            break

          case 1: // reading data
            v.push(c)
            if (v.length == this.size) {
              this.state = 2
            }
            break

          case 2: // reading crlf
            if (v.length > this.size+2) {
              reject('invalid chunk encoding')
            }

            // lets read off crlf, then resolve
            v.push(c)
            if (l == 13 && c == 10) {
              const value = this.utf8ArrayToStr(v.splice(0,v.length-2))
              v.length = 0
              this.state = 0
              this.decoded.push(value)
            }
            break

          case 3: // done
            break
        }
        
        i++
      }

      resolve(this.decoded)
    })
  }

  utf8ArrayToStr(bytes: Uint8Array | number[]): string {
    let str = '', i = 0, len = bytes.length, c = 0, char2 = 0, char3 = 0
    while(i < len) {
      c = bytes[i++]
      switch(c >> 4) { 
        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
          // 0xxxxxxx
          str += String.fromCharCode(c)
          break
        case 12: case 13:
          // 110x xxxx   10xx xxxx
          char2 = bytes[i++]
          str += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F))
          break
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = bytes[i++]
          char3 = bytes[i++]
          str += String.fromCharCode(
            ((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)
          )
          break
      }
    }
    return str
  }
}

//
// Client
//
export class ExampleService implements ExampleService {
  private _hostname: string
  private _fetch: Fetch
  private _path = '/rpc/ExampleService/'
  private _defaultHeaders?: object

  // TODO: perhaps include default headers or something..?

  constructor(hostname: string, fetch: Fetch, defaultHeaders?: object) {
    this._hostname = hostname
    this._fetch = fetch
    this._defaultHeaders = defaultHeaders || {}
  }

  private _url(name: string): string {
    return this._hostname + this._path + name
  }

  set clientDefaultHeaders(defaultHeaders: object) {
    this._defaultHeaders = defaultHeaders
  }

  ping = (headers?: object): Promise<PingReturn> => {
    return this._fetch(
      this._url('Ping'),
      createHTTPRequest({}, { ...this._defaultHeaders, headers })
    ).then(resp => {
      return buildResponse(resp).then(_data => {
        return {
          // status: <boolean>(_data.status)
        }
      })
    })
  }
  
  getUser = (args: GetUserArgs, headers?: object): Promise<GetUserReturn> => {
    return this._fetch(
      this._url('GetUser'),
      createHTTPRequest(args, { ...this._defaultHeaders, headers })
    ).then(resp => {
      return buildResponse(resp).then(_data => {
        return {
          user: <User>(_data.user)
        }
      })
    })
  }
  
  download = async (args: DownloadArgs, headers?: object): Promise<DownloadStream> => {
    const stream = new StreamClient<DownloadArgs, DownloadReturn>(this._fetch, this._url('Download'))//, args, headers)
    // const stream = new StreamReader(this.fetch, this.url('Download'), args, headers)
    await stream.open(args, headers) // to be or not to be....?
    return stream
  }
  
}

// TODO: use a class..?
export interface WebRPCError extends Error {
  code: string
  message: string
}

const createHTTPRequest = <TBody>(body: TBody | object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json', 'Accept': '*/*' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', message: `client error, expecting JSON object but got: '${text}'` } as WebRPCError
    }
    if (!res.ok) {
      throw data as WebRPCError // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
